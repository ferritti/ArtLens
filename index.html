<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ArtLens â€” Real-time Artwork Detector (Phase 1)</title>
  <style>
    /* Museum theme: elegant, artistic, premium */
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap');

    :root {
      color-scheme: dark;
      /* Brand palette */
      --bg-0: #0e0f12;         /* deep charcoal */
      --bg-1: #14161b;         /* slightly lighter for layers */
      --fg:   #eceae6;         /* off-white text */
      --muted:#b7b1a6;         /* muted text */
      --accent: #c5a46d;       /* museum gold */
      --accent-ink: #221a10;   /* dark text on gold */

      /* Detection overlay colors used by JS */
      --box-color: var(--accent);
      --box-fill: rgba(197, 164, 109, 0.14);
      --label-bg: rgba(10, 11, 14, 0.72);
      --label-fg: #f5f3ef;

      --radius-card: 20px;
      --radius-placard: 14px;
      --shadow-xl: 0 20px 50px rgba(0,0,0,0.45);
      --shadow-md: 0 10px 24px rgba(0,0,0,0.35);
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* camera is the background */
      background: var(--bg-0);
      color: var(--fg);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    /* Ensure padding and border are included in element widths to prevent right-side clipping on mobile */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* Full-viewport stage */
    .stage {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      background: var(--bg-0);
      isolation: isolate; /* for overlays */
    }
    /* subtle vignette for premium feel */
    .stage::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(120% 90% at 50% -10%, rgba(197,164,109,0.12) 0%, rgba(0,0,0,0) 40%),
                  radial-gradient(100% 100% at 50% 120%, rgba(0,0,0,0.65) 0%, rgba(0,0,0,0.2) 45%, rgba(0,0,0,0) 70%);
      z-index: 1;
      pointer-events: none;
    }

    /* Video as the background */
    #camera {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
      z-index: 0; /* behind overlays */
      filter: saturate(0.95) contrast(1.03);
    }

    /* Transparent overlay canvas perfectly aligned with the video */
    #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 2;
      pointer-events: none;
    }

    /* Top brand bar */
    .topbar {
      position: absolute;
      top: calc(env(safe-area-inset-top) + 14px);
      left: calc(env(safe-area-inset-left) + 16px);
      right: calc(env(safe-area-inset-right) + 16px);
      z-index: 4;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      pointer-events: none; /* purely decorative */
    }
    .brand {
      font-family: "Cormorant Garamond", Georgia, serif;
      font-weight: 600;
      font-size: clamp(18px, 2.2vw, 24px);
      letter-spacing: 0.4px;
      color: var(--fg);
      text-shadow: 0 1px 0 rgba(0,0,0,0.4);
    }
    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(197,164,109,0.16);
      color: var(--accent);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      border: 1px solid rgba(197,164,109,0.24);
    }

    /* HUD */
    .hud {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 3;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .card {
      display: grid;
      gap: 18px;
      width: min(92vw, 580px);
      background: linear-gradient(180deg, rgba(20,22,27,0.80), rgba(20,22,27,0.62));
      padding: 22px 22px 20px;
      border-radius: var(--radius-card);
      color: var(--fg);
      text-align: center;
      backdrop-filter: blur(16px) saturate(1.05);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: var(--shadow-xl);
      animation: fadeInUp 600ms ease both;
    }
    .card-title {
      font-family: "Cormorant Garamond", Georgia, serif;
      font-weight: 600;
      font-size: clamp(20px, 2.6vw, 28px);
      letter-spacing: 0.2px;
      margin-bottom: 8px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
    }
    .actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 0;
    }
    button {
      appearance: none;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      background: linear-gradient(180deg, var(--accent), #b89558);
      color: var(--accent-ink);
      font-weight: 700;
      font-size: 16px;
      letter-spacing: 0.2px;
      box-shadow: 0 6px 20px rgba(197,164,109,0.35), inset 0 1px 0 rgba(255,255,255,0.35);
      transform: translateY(0);
      transition: transform 180ms ease, box-shadow 180ms ease, opacity 180ms ease;
      cursor: pointer;
    }
    button:hover { box-shadow: 0 10px 26px rgba(197,164,109,0.45), inset 0 1px 0 rgba(255,255,255,0.4); transform: translateY(-1px); }
    button:active { transform: translateY(0); box-shadow: 0 6px 18px rgba(197,164,109,0.35) inset; }
    button:disabled { opacity: 0.6; cursor: default; }

    .hidden { display: none !important; }
    .status { font-size: 13px; opacity: 0.9; color: var(--muted); line-height: 1.5; }

    /* Subtle premium hint bubble (positioned near detected box by JS) */
    .hint {
      position: absolute;
      top: -9999px;
      left: -9999px;
      transform: translate(-50%, 0);
      z-index: 6;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(20,22,27,0.72);
      color: var(--fg);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow-md);
      font-size: 14px;
      line-height: 1.2;
      backdrop-filter: blur(12px) saturate(1.08);
      pointer-events: none;
      animation: fadeInUp 400ms ease both;
      text-align: center;
      white-space: normal;
      max-width: calc(100vw - 32px);
    }

    /* Info placard (art label) */
    #info.placard {
      position: absolute;
      left: 50%;
      bottom: calc(env(safe-area-inset-bottom) + 16px);
      transform: translateX(-50%);
      z-index: 3;
      max-width: min(92vw, 720px);
      background: #f5f3ef;
      color: #1a1c1a;
      padding: 14px 16px;
      border-radius: var(--radius-placard);
      border: 1px solid rgba(26, 28, 26, 0.08);
      box-shadow: var(--shadow-md);
      font-family: "Cormorant Garamond", Georgia, serif;
      line-height: 1.3;
      display: none; /* JS will set display:block to show */
    }
    #info.placard .muted { color: #4b4b4b; }

    /* Clickable hotspot positioned over recognized artwork */
    .hotspots {
      position: absolute;
      inset: 0;
      z-index: 7;
      pointer-events: none; /* only hotspots receive events */
    }
    .hotspot {
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: auto;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(20,22,27,0.92), rgba(20,22,27,0.75));
      color: var(--fg);
      border: 1px solid rgba(197,164,109,0.6);
      box-shadow: var(--shadow-md);
      backdrop-filter: blur(12px) saturate(1.06);
      cursor: pointer;
      animation: fadeInUp 280ms ease both;
    }
    .hotspot::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      box-shadow: 0 0 0 0 rgba(197,164,109,0.45);
      animation: pulse 1600ms ease-out infinite;
      pointer-events: none;
    }
    .hotspot .icon {
      font-size: 20px;
      line-height: 1;
      transform: translateY(1px);
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.4));
    }

    /* Detail overlay panel */
    .detail {
      position: absolute;
      inset: 0;
      z-index: 10;
      display: grid;
      place-items: center;
      padding: calc(env(safe-area-inset-top) + 12px) 16px calc(env(safe-area-inset-bottom) + 16px);
      background: radial-gradient(100% 120% at 50% -20%, rgba(197,164,109,0.10), rgba(0,0,0,0) 45%),
                  linear-gradient(180deg, rgba(14,15,18,0.75), rgba(14,15,18,0.55));
      backdrop-filter: blur(18px) saturate(1.06);
    }
    .detail-card {
      width: min(92vw, 720px);
      background: linear-gradient(180deg, rgba(245,243,239,0.98), rgba(245,243,239,0.90));
      color: #1a1c1a;
      border-radius: var(--radius-card);
      border: 1px solid rgba(26,28,26,0.08);
      box-shadow: var(--shadow-xl);
      padding: 22px;
      animation: fadeInUp 400ms ease both;
    }
    .detail-title {
      font-family: "Cormorant Garamond", Georgia, serif;
      font-weight: 700;
      font-size: clamp(22px, 3.2vw, 32px);
      letter-spacing: 0.3px;
      margin-bottom: 6px;
    }
    .detail-meta { color: #4b4b4b; font-size: 14px; margin-bottom: 12px; }
    .detail-body { color: #333; font-size: 15px; line-height: 1.6; }
    .detail-actions { margin-top: 18px; display: flex; justify-content: center; }
    .detail .back { background: linear-gradient(180deg, var(--accent), #b89558); color: var(--accent-ink); padding: 12px 18px; border-radius: 999px; font-weight: 700; box-shadow: var(--shadow-md); }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translate3d(0, 8px, 0); }
      to { opacity: 1; transform: translate3d(0, 0, 0); }
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(197,164,109,0.5); }
      100% { box-shadow: 0 0 0 14px rgba(197,164,109,0); }
    }
  </style>
</head>
<body>
  <main class="stage" id="app">
    <video id="camera" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <div class="topbar">
      <div class="brand">ArtLens</div>
    </div>

    <div id="info" class="placard"></div>
    <div id="hint" class="hint hidden" aria-live="polite">Tocca lâ€™opera</div>
    <div id="hotspots" class="hotspots"></div>

    <div id="detail" class="detail hidden" aria-modal="true" role="dialog">
      <div class="detail-card">
        <div class="detail-title" id="detailTitle"></div>
        <div class="detail-meta" id="detailMeta"></div>
        <div class="detail-body" id="detailBody"></div>
        <div class="detail-actions">
          <button id="backBtn" class="back" type="button">Torna alla Fotocamera</button>
        </div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div class="card">
        <div>
          <div class="card-title">Scopri l'arte intorno a te</div>
          <div class="status" id="status">Inquadra un'opera per scoprirne la storia.</div>
        </div>
        <div class="actions">
          <button id="startBtn">Attiva Fotocamera</button>
        </div>
      </div>
    </div>
  </main>

  <!-- TensorFlow.js and MobileNet -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>
  <script type="module">
    // Import MediaPipe Tasks Vision from CDN
    import { FilesetResolver, ObjectDetector } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    const MODEL_URL = "model.tflite"; // TODO: Replace with your .tflite model URL or relative path
    const ART_DB_URL = "artwork_database.json"; // embeddings database file

    const appEl = document.getElementById('app');
    const videoEl = document.getElementById('camera');
    const canvasEl = document.getElementById('overlay');
    const hudEl = document.getElementById('hud');
    const startBtn = document.getElementById('startBtn');
    const statusEl = document.getElementById('status');
    const infoEl = document.getElementById('info');
    const hintEl = document.getElementById('hint');
    const hotspotsEl = document.getElementById('hotspots');
    const detailEl = document.getElementById('detail');
    const detailTitleEl = document.getElementById('detailTitle');
    const detailMetaEl = document.getElementById('detailMeta');
    const detailBodyEl = document.getElementById('detailBody');
    const backBtn = document.getElementById('backBtn');

    let detector = null;
    let stream = null;
    let running = false;

    // Embedding model and DB
    let embedModel = null; // MobileNet feature extractor
    let artworkDB = []; // { id, title, description, embedding: number[] (normalized) }
    let dbDim = null;
    let runtimeDim = null; // embedding dimension produced at runtime
    let categoryLogCount = 0; // limited logging of detector categories

    // Offscreen canvas for crops
    const cropSize = 224; // MobileNet input size
    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = cropCanvas.height = cropSize;
    const cropCtx = cropCanvas.getContext('2d', { willReadFrequently: true });

    // Matching settings
    const COSINE_THRESHOLD = 0.75; // lowered for initial testing; tune as needed [0..1]
    const DEBUG_FALLBACK_CROP = false; // debug-only: try center crop when no detections

    // Keep track of last processed timestamp to avoid duplicate frames
    let lastVideoTime = -1;

    // UI/recognition state
    let lastMatches = [];
    let lastRecognizedKey = null;
    let hintHideTimer = null;

    function showHintFor(entry, box) {
      const text = "Tocca lâ€™opera";
      if (hintEl) {
        hintEl.textContent = text;
        placeHintOverBox(box);
        hintEl.classList.remove('hidden');
        scheduleHideHint(3000);
      }
    }

    function hideHint() {
      if (hintHideTimer) { clearTimeout(hintHideTimer); hintHideTimer = null; }
      if (hintEl) hintEl.classList.add('hidden');
    }

    function scheduleHideHint(ms = 3000) {
      if (hintHideTimer) clearTimeout(hintHideTimer);
      hintHideTimer = setTimeout(() => { hideHint(); }, ms);
    }

    function clientPointToVideo(clientX, clientY) {
      const rect = appEl.getBoundingClientRect();
      const vW = videoEl.videoWidth || 1;
      const vH = videoEl.videoHeight || 1;
      const dW = rect.width;
      const dH = rect.height;
      const scale = Math.max(dW / vW, dH / vH); // object-fit: cover
      const displayW = vW * scale;
      const displayH = vH * scale;
      const offsetX = rect.left + (dW - displayW) / 2;
      const offsetY = rect.top + (dH - displayH) / 2;
      const x = (clientX - offsetX) / scale;
      const y = (clientY - offsetY) / scale;
      return { x, y };
    }

    function pointInBox(px, py, box, pad = 6) {
      const x1 = box.originX - pad;
      const y1 = box.originY - pad;
      const x2 = box.originX + box.width + pad;
      const y2 = box.originY + box.height + pad;
      return px >= x1 && px <= x2 && py >= y1 && py <= y2;
    }

    // Map video coordinates to on-screen (CSS pixel) coordinates considering object-fit: cover
    function getDisplayMapping() {
      const rect = appEl.getBoundingClientRect();
      const vW = videoEl.videoWidth || 1;
      const vH = videoEl.videoHeight || 1;
      const dW = rect.width;
      const dH = rect.height;
      const scale = Math.max(dW / vW, dH / vH);
      const displayW = vW * scale;
      const displayH = vH * scale;
      const offsetX = (dW - displayW) / 2;
      const offsetY = (dH - displayH) / 2;
      return { scale, offsetX, offsetY, dW, dH };
    }
    function videoPointToDisplay(vx, vy) {
      const map = getDisplayMapping();
      return { x: map.offsetX + vx * map.scale, y: map.offsetY + vy * map.scale, dW: map.dW, dH: map.dH };
    }
    function placeHintOverBox(box) {
      if (!hintEl || !box) return;
      const map = getDisplayMapping();
      const dx = map.offsetX + (box.originX || 0) * map.scale;
      const dy = map.offsetY + (box.originY || 0) * map.scale;
      const dw = (box.width || 0) * map.scale;
      const dh = (box.height || 0) * map.scale;
      const margin = 12;
      // Center horizontally within the box but clamp to its edges with some padding
      const cx = dx + dw / 2;
      const clampedCenter = Math.max(dx + margin, Math.min(dx + Math.max(0, dw - margin), cx));
      // Place slightly inside the top of the box
      const y = Math.max(margin, Math.min(map.dH - margin, dy + Math.max(8, Math.min(16, dh * 0.06))));
      hintEl.style.left = `${clampedCenter}px`;
      hintEl.style.top = `${y}px`;
      const maxW = Math.max(100, Math.floor(Math.min(Math.max(0, dw - margin * 2), map.dW - margin * 2)));
      if (isFinite(maxW) && maxW > 0) hintEl.style.maxWidth = `${maxW}px`;
    }

    function clearHotspots() {
      if (!hotspotsEl) return;
      hotspotsEl.innerHTML = '';
    }
    function renderHotspot(match) {
      if (!hotspotsEl || !match) return;
      clearHotspots();
      const { entry, confidence, box } = match;
      const map = getDisplayMapping();
      const dx = map.offsetX + (box.originX || 0) * map.scale;
      const dy = map.offsetY + (box.originY || 0) * map.scale;
      const dw = (box.width || 0) * map.scale;
      const dh = (box.height || 0) * map.scale;
      const margin = 12;
      let hx = Math.max(margin, Math.min(map.dW - margin, dx + dw * 0.5));
      let hy = Math.max(margin, Math.min(map.dH - margin, dy + Math.max(16, Math.min(32, dh * 0.12))));
      const btn = document.createElement('button');
      btn.className = 'hotspot';
      btn.type = 'button';
      btn.innerHTML = '<span class="icon" aria-hidden="true">ðŸ‘†</span>';
      btn.setAttribute('aria-label', 'Tocca per i dettagli sullâ€™opera');
      btn.title = 'Tocca per i dettagli';
      btn.style.left = `${hx}px`;
      btn.style.top = `${hy}px`;
      btn.addEventListener('click', (e) => { e.stopPropagation(); openDetail(entry, confidence); });
      hotspotsEl.appendChild(btn);
    }

    function openDetail(entry, confidence) {
      try { infoEl.style.display = 'none'; } catch {}
      hideHint();
      clearHotspots();
      if (detailTitleEl) detailTitleEl.textContent = entry?.title || 'Opera';
      let meta = '';
      if (entry?.artist) meta += entry.artist;
      if (entry?.year) meta += (meta ? ' Â· ' : '') + entry.year;
      if (entry?.museum || entry?.location) meta += (meta ? ' Â· ' : '') + (entry.museum || entry.location);
      if (detailMetaEl) detailMetaEl.textContent = meta;
      if (detailBodyEl) detailBodyEl.textContent = entry?.description || '';
      if (detailEl) detailEl.classList.remove('hidden');
      // Pause detection loop and clear overlay
      running = false;
      try { const ctx = canvasEl.getContext('2d'); ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); } catch {}
    }
    function closeDetail() {
      if (detailEl) detailEl.classList.add('hidden');
      // Clear any transient UI/state to avoid immediate re-open due to bubbling/cached matches
      try { hideHint(); } catch {}
      try { showInfo(null); } catch {}
      try { clearHotspots(); } catch {}
      lastMatches = [];
      lastRecognizedKey = null;
      if (!running) { running = true; startLoop(); }
    }
    backBtn?.addEventListener('click', (e) => {
      e.preventDefault();
      // Prevent this click from bubbling to #app where it could re-trigger openDetail
      if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
      if (typeof e.stopPropagation === 'function') e.stopPropagation();
      closeDetail();
    });

    appEl.addEventListener('click', (ev) => {
      if (!running) return;
      if (!lastMatches || !lastMatches.length) return;
      const pt = clientPointToVideo(ev.clientX, ev.clientY);
      let best = null;
      for (const m of lastMatches) {
        if (pointInBox(pt.x, pt.y, m.box, 8)) {
          if (!best || m.confidence > best.confidence) best = m;
        }
      }
      if (best) {
        openDetail(best.entry, best.confidence);
      }
    });

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      try {
        // Start camera first to ensure permission prompt and preview appear immediately
        status("Starting cameraâ€¦");
        await startCamera();
        hudEl.classList.add('hidden');
        running = true;
        startLoop();

        // Initialize models in the background; do not block the camera
        try {
          status("Initializing object detectorâ€¦");
          await initDetector();
          status("Loading embedding modelâ€¦");
          await initEmbeddingModel();
          status("Loading artwork databaseâ€¦");
          await loadArtworkDB();
          status("Ready");
        } catch (modelErr) {
          console.warn('Model init error (continuing with camera only):', modelErr);
          status("Camera running. Model init failed: " + (modelErr?.message || modelErr));
        }
      } catch (err) {
        console.error(err);
        startBtn.disabled = false;
        status("Error: " + (err?.message || err));
      }
    });

    function status(msg) {
      statusEl.textContent = msg;
    }

    function showInfo(name, description, confidence) {
      if (!name) {
        infoEl.style.display = 'none';
        return;
      }
      const conf = (confidence * 100).toFixed(1);
      infoEl.innerHTML = `<div style="font-weight:700;margin-bottom:4px;">${name} <span style="opacity:.8;font-weight:500;">(${conf}%)</span></div><div style="opacity:.9;">${description || ''}</div>`;
      infoEl.style.display = 'block';
      // When info is shown, hide the hint
      hideHint();
    }

    async function initDetector() {
      // Load WASM assets for the vision tasks from the CDN
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
      );

      detector = await ObjectDetector.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath: MODEL_URL,
          delegate: 'GPU'
        },
        runningMode: 'VIDEO',
        scoreThreshold: 0.3
      });
    }

    async function initEmbeddingModel() {
      const tf = globalThis.tf;
      const mobilenetGlobal = globalThis.mobilenet;
      if (!tf) throw new Error('TensorFlow.js non caricato');
      try { await tf.setBackend('webgl'); } catch {}
      await tf.ready();
      if (!mobilenetGlobal) throw new Error('MobileNet non caricato');
      // Load MobileNet v2 feature extractor
      embedModel = await mobilenetGlobal.load({ version: 2, alpha: 1.0 });
      // Warmup and detect runtime embedding dimension
      try {
        tf.tidy(() => {
          const dummy = tf.zeros([224, 224, 3]);
          const emb = embedModel.infer(dummy, true);
          runtimeDim = emb.size;
        });
        console.log('MobileNet ready, backend:', tf.getBackend(), 'runtimeDim:', runtimeDim);
      } catch (e) {
        console.warn('MobileNet warmup failed:', e);
      }
    }

    function ensureEmbeddingModelMatchesDB() {
      try {
        const tf = globalThis.tf;
        if (!embedModel) return;
        if (runtimeDim == null && tf) {
          tf.tidy(() => {
            const dummy = tf.zeros([224, 224, 3]);
            const emb = embedModel.infer(dummy, true);
            runtimeDim = emb.size;
          });
        }
        if (dbDim != null && runtimeDim != null && dbDim !== runtimeDim) {
          console.warn(`Embedding dimension mismatch: DB=${dbDim}, runtime=${runtimeDim}. Rigenera gli embedding del DB con lo stesso MobileNet e preprocessing.`);
        }
      } catch (e) {
        console.warn('ensureEmbeddingModelMatchesDB error:', e);
      }
    }

    async function loadArtworkDB() {
      try {
        const res = await fetch(ART_DB_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Failed to load database: ${res.status}`);
        const data = await res.json();

        // Support array, {items: []}, or object-map { key: { ... } }
        if (Array.isArray(data)) {
          artworkDB = data;
        } else if (Array.isArray(data?.items)) {
          artworkDB = data.items;
        } else if (data && typeof data === 'object') {
          artworkDB = Object.entries(data).map(([id, v]) => ({ id, ...v }));
        } else {
          artworkDB = [];
        }

        // Normalize embeddings and determine dimension
        dbDim = null;
        let normalized = 0;
        for (const e of artworkDB) {
          if (!Array.isArray(e.embedding)) continue;
          const norm = Math.hypot(...e.embedding);
          if (norm > 0) {
            e.embedding = e.embedding.map(v => v / norm);
            normalized++;
          }
          dbDim = dbDim ?? e.embedding.length;
        }
        if (dbDim != null) {
          try { await ensureEmbeddingModelMatchesDB(); } catch (e) { console.warn('Ensure embedding dim match failed:', e); }
        }
        console.log('Artwork DB entries:', artworkDB.length, 'dim:', dbDim, 'normalized:', normalized);
        if (!artworkDB.length) {
          console.warn('Artwork DB Ã¨ vuoto dopo il parsing. Controlla il formato JSON.');
        }
      } catch (e) {
        console.warn('Artwork DB load failed, proceeding with empty DB.', e);
        artworkDB = [];
        dbDim = null;
      }
    }

    async function startCamera() {
      // Basic environment checks
      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error('Camera API non disponibile. Usa un browser moderno su HTTPS o localhost.');
      }
      if (!window.isSecureContext && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        throw new Error('La videocamera richiede HTTPS (oppure localhost). Apri la pagina con https:// o avvia un server locale.');
      }

      // Ensure best compatibility on mobile Safari/Chrome
      try { videoEl.setAttribute('playsinline', ''); } catch {}
      try { videoEl.setAttribute('webkit-playsinline', ''); } catch {}
      try { videoEl.setAttribute('muted', ''); } catch {}
      videoEl.playsInline = true;
      videoEl.muted = true; // required for autoplay in many mobile browsers
      videoEl.autoplay = true;

      // Prefer rear camera on mobile; try multiple fallbacks
      const constraintAttempts = [
        { video: { facingMode: { exact: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false },
        { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
        { video: { facingMode: 'environment' }, audio: false },
        { video: true, audio: false }
      ];

      let lastError = null;
      for (const constraints of constraintAttempts) {
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          break;
        } catch (e) {
          lastError = e;
        }
      }
      if (!stream) {
        const msg = lastError?.name === 'NotAllowedError'
          ? 'Accesso alla camera negato. Vai nelle impostazioni del browser e consenti l\'uso della fotocamera per questo sito.'
          : `Impossibile avviare la camera: ${lastError?.message || lastError || 'sconosciuto'}`;
        throw new Error(msg);
      }

      // Attach stream
      try { videoEl.srcObject = null; } catch {}
      videoEl.srcObject = stream;

      // Ensure playback starts reliably across browsers
      let played = false;
      try {
        await videoEl.play();
        played = true;
      } catch (e) {
        // Some browsers require waiting metadata before play
      }
      if (!played) {
        await new Promise((res) => {
          const onMeta = async () => {
            videoEl.removeEventListener('loadedmetadata', onMeta);
            try { await videoEl.play(); } catch {}
            res();
          };
          if (videoEl.readyState >= 2 && videoEl.videoWidth > 0) return onMeta();
          videoEl.addEventListener('loadedmetadata', onMeta);
        });
      }

      // Ensure the overlay canvas intrinsically matches the video frame size
      resizeCanvasToVideo();

      // Keep intrinsic size in sync if orientation or track settings change
      window.addEventListener('resize', resizeCanvasToVideo);
      window.addEventListener('orientationchange', resizeCanvasToVideo);
    }

    function resizeCanvasToVideo() {
      const vw = videoEl.videoWidth || 1280;
      const vh = videoEl.videoHeight || 720;
      const dpr = Math.min(window.devicePixelRatio || 1, 3);

      // Set canvas internal resolution to video resolution scaled by DPR for crisp lines
      canvasEl.width = Math.max(1, Math.floor(vw * dpr));
      canvasEl.height = Math.max(1, Math.floor(vh * dpr));

      // The CSS size is controlled via styles (100% with object-fit: cover)
      const ctx = canvasEl.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Scale drawing so coordinates match video pixels
      ctx.imageSmoothingEnabled = false;
    }

    function startLoop() {
      const ctx = canvasEl.getContext('2d');

      const loop = async () => {
        if (!running) return;

        const now = performance.now();
        const t = videoEl.currentTime;
        // Avoid redundant inference on the same frame
        if (detector && videoEl.readyState >= 2 && (t !== lastVideoTime)) {
          lastVideoTime = t;
          const result = detector.detectForVideo(videoEl, now);
          drawDetections(ctx, result);
        }
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function cropToCanvasFromVideo(box) {
      const vx = clamp(box.originX, 0, videoEl.videoWidth);
      const vy = clamp(box.originY, 0, videoEl.videoHeight);
      const vw = clamp(box.width, 1, videoEl.videoWidth - vx);
      const vh = clamp(box.height, 1, videoEl.videoHeight - vy);
      // draw crop scaled to 224x224
      cropCtx.clearRect(0, 0, cropSize, cropSize);
      cropCtx.drawImage(videoEl, vx, vy, vw, vh, 0, 0, cropSize, cropSize);
      return cropCanvas;
    }

    function embedFromCanvas(can) {
      const tf = globalThis.tf;
      if (!tf || !embedModel) throw new Error('Embedding model non disponibile');
      // Returns a normalized Float32Array embedding
      const arr = tf.tidy(() => {
        const input = tf.browser.fromPixels(can);
        const embedding = embedModel.infer(input, true); // MobileNet embedding tensor [D]
        const flat = embedding.flatten();
        return flat.arraySync();
      });
      // Normalize
      const norm = Math.hypot(...arr);
      return norm > 0 ? arr.map(v => v / norm) : arr;
    }

    function cosineSim(vecA, vecB) {
      if (!vecA || !vecB || vecA.length !== vecB.length) return -1;
      let dot = 0;
      for (let i = 0; i < vecA.length; i++) dot += vecA[i] * vecB[i];
      return dot; // already normalized vectors
    }

    function findBestMatch(embedding) {
      if (!artworkDB.length) return null;
      let best = { idx: -1, sim: -1 };
      for (let i = 0; i < artworkDB.length; i++) {
        const e = artworkDB[i];
        if (!Array.isArray(e.embedding)) continue;
        if (dbDim != null && e.embedding.length !== embedding.length) continue; // skip mismatched dims
        const sim = cosineSim(embedding, e.embedding);
        if (sim > best.sim) best = { idx: i, sim };
      }
      if (best.idx < 0) return null;
      const entry = artworkDB[best.idx];
      return { entry, confidence: best.sim };
    }

    function drawDetections(ctx, result) {
      const w = videoEl.videoWidth;
      const h = videoEl.videoHeight;
      // Clear the full logical canvas area (use unscaled units)
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Clear in device pixels-aware size
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
      ctx.restore();

      ctx.lineWidth = 3;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--box-color') || '#2ee6a7';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--box-fill') || 'rgba(46,230,167,0.15)';
      ctx.font = '14px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
      lastMatches = [];

      if (!result?.detections?.length) {
        lastMatches = [];
        let fallbackMatched = false;
        // Optional debug fallback: try a central crop to validate embedding pipeline
        if (DEBUG_FALLBACK_CROP && embedModel) {
          try {
            const box = { originX: w * 0.25, originY: h * 0.25, width: w * 0.5, height: h * 0.5 };
            const crop = cropToCanvasFromVideo(box);
            const emb = embedFromCanvas(crop);
            const matched = findBestMatch(emb);
            if (matched && matched.confidence >= COSINE_THRESHOLD) {
              const { entry, confidence } = matched;
              lastMatches.push({ entry, confidence, box });
              fallbackMatched = true;

              // draw pseudo box and label
              ctx.beginPath();
              ctx.rect(box.originX, box.originY, box.width, box.height);
              ctx.fill();
              ctx.stroke();

              const uiLabel = `${entry.title || 'Artwork'} ${(confidence*100).toFixed(1)}%`;
              const textPaddingX = 6;
              const textPaddingY = 4;
              const metrics = ctx.measureText(uiLabel);
              const textW = metrics.width + textPaddingX * 2;
              const textH = 18 + textPaddingY * 2;
              ctx.save();
              ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--label-bg') || 'rgba(0,0,0,0.6)';
              ctx.strokeStyle = 'transparent';
              ctx.beginPath();
              ctx.rect(box.originX, Math.max(0, box.originY - textH), textW, textH);
              ctx.fill();
              ctx.restore();

              ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--label-fg') || '#fff';
              ctx.fillText(uiLabel, box.originX + textPaddingX, Math.max(12 + textPaddingY, box.originY - textH + 12 + textPaddingY));

              const key = (entry && (entry.id != null ? String(entry.id) : (entry.title || '')));
              if (key && key !== lastRecognizedKey) {
                lastRecognizedKey = key;
                showHintFor(entry, box);
              }
              // render hotspot near the detection
              renderHotspot({ entry, confidence, box });
            }
          } catch (e) { console.warn('Fallback match failed:', e); }
        }
        if (!fallbackMatched) {
          lastRecognizedKey = null;
          hideHint();
          showInfo(null);
          clearHotspots();
        }
        return;
      }

      let anyMatch = false;
      for (const det of result.detections) {
        const box = det.boundingBox; // { originX, originY, width, height }
        const x = box.originX;
        const y = box.originY;
        const bw = box.width;
        const bh = box.height;

        // Filled box for subtle highlight
        ctx.beginPath();
        ctx.rect(x, y, bw, bh);
        ctx.fill();
        ctx.stroke();

        // Label and recognition
        const cat = det.categories?.[0];
        if (cat) {
          if (categoryLogCount < 8) {
            try { console.log('Detected categories:', det.categories?.map(c => ({ name: c.categoryName, score: c.score }))); } catch {}
            categoryLogCount++;
          }
          let name = cat.categoryName || 'artwork';
          let confDisplay = cat.score != null ? (cat.score*100).toFixed(0) + '%' : '';
          let uiLabel = `${name}${confDisplay ? ` ${confDisplay}` : ''}`;
          let matched = null;

          try {
            if (embedModel) {
              const crop = cropToCanvasFromVideo(box);
              const emb = embedFromCanvas(crop);
              matched = findBestMatch(emb);
            }
          } catch (e) {
            // Fail-safe: keep default label
            console.warn('Embedding/match failed:', e);
          }

          if (matched && matched.confidence >= COSINE_THRESHOLD) {
            const { entry, confidence } = matched;
            uiLabel = `${entry.title || 'Artwork'} ${(confidence*100).toFixed(1)}%`;
            lastMatches.push({ entry, confidence, box });
            anyMatch = true;
          }

          const textPaddingX = 6;
          const textPaddingY = 4;
          const metrics = ctx.measureText(uiLabel);
          const textW = metrics.width + textPaddingX * 2;
          const textH = 18 + textPaddingY * 2;

          // Background box behind label at top-left of the detection
          ctx.save();
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--label-bg') || 'rgba(0,0,0,0.6)';
          ctx.strokeStyle = 'transparent';
          ctx.beginPath();
          ctx.rect(x, Math.max(0, y - textH), textW, textH);
          ctx.fill();
          ctx.restore();

          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--label-fg') || '#fff';
          ctx.fillText(uiLabel, x + textPaddingX, Math.max(12 + textPaddingY, y - textH + 12 + textPaddingY));
        }
      }

      if (!anyMatch) {
        // Hide info panel and hint when no confident match on this frame
        lastRecognizedKey = null;
        hideHint();
        showInfo(null);
        clearHotspots();
      } else if (lastMatches && lastMatches.length) {
        // Pick the highest-confidence match this frame
        let best = lastMatches[0];
        for (const m of lastMatches) if (m.confidence > best.confidence) best = m;
        // Render a clickable hotspot over the artwork
        renderHotspot(best);
        // Reposition the recognition hint inside the bounding box each frame
        placeHintOverBox(best.box);
        const key = (best.entry && (best.entry.id != null ? String(best.entry.id) : (best.entry.title || '')));
        if (key && key !== lastRecognizedKey) {
          lastRecognizedKey = key;
          showHintFor(best.entry, best.box);
        }
      }
    }

    // Graceful cleanup when navigating away
    window.addEventListener('pagehide', stopAll, { once: true });
    window.addEventListener('beforeunload', stopAll, { once: true });

    function stopAll() {
      running = false;
      if (detector) {
        try { detector.close && detector.close(); } catch {}
        detector = null;
      }
      if (stream) {
        for (const track of stream.getTracks?.() || []) track.stop();
        stream = null;
      }
    }

    // Tip: For local development, serve over HTTPS (or localhost) for camera permissions.
  </script>
</body>
</html>
